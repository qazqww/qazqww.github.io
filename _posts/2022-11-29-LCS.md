---
layout: post
title: "LCS 알고리즘"
categories: algorithm
tags: [string]
---

#### *
나는 문자열에 관한 알고리즘에는 별로 익숙하지 않다. 문자열 관련 문제들은 보면 간단하게 풀이가 떠오르긴 하지만, 그 풀이들은 웬만하면 시간 초과로 틀린다. 알고리즘 초보 때는 그렇게 틀리고 헤매다 풀지 못했던 적이 많아 거부감이 생겼던 것 같다. 이 거부감을 극복하고자 일단 LCS(Longest Common Subsequence) 알고리즘부터 한 번 정리해보고자 한다.
<br>

#### 용도
두 문자열이 있을 때, 둘 모두의 부분이 되는 부분수열을 이어 만들 수 있는 가장 긴 문자열을 만든다.
예) ABCDE와 ABEFG의 LCS는 ABE이다.

※ Longest Common Substring 알고리즘과 혼동하기 쉬운데, 이는 한번에 이어져있는 문자열을 구하는 알고리즘이다.
<br>

#### 시간 복잡도
- 기본적으로 **O(n^2^)** 의 복잡도를 가진다.
<br>

#### 개념
1. 문자열 A와 문자열 B를 한 글자씩 비교해나간다.

2. 2차원 배열에 DP 식으로 결과를 적어나간다.\
    2-0. 배열의 첫 라인들을 기본값(0)으로 채워넣는다.

    2-1. 문자열 A의 i번째 글자와 문자열 B의 j번째 글자가 같은 경우\
    -> dp[i-1][j-1]의 값 + 1을 dp[i][j]에 기록한다.

    2-2. 다른 경우\
    -> dp[i-1][j]의 값과 dp[i][j-1]의 값 중 높은 값을 dp[i][j]에 기록한다.

3. dp[i][j]의 값을 취한다.

|   | - | A | B | C | D | E |
|----|----|----|----|----|----|----|
| - | 0 | 0 | 0 | 0 | 0 | 0 |
| A | 0 | 1 | 1 | 1 | 1 | 1 |
| B | 0 | 1 | 2 | 2 | 2 | 2 |
| E | 0 | 1 | 2 | 2 | 2 | 3 |
| F | 0 | 1 | 2 | 2 | 2 | 3 |
| G | 0 | 1 | 2 | 2 | 2 | 3 |

2-1의 경우, A.substring(0, i-1)과 B.substring(0, j-1)까지 비교한 값에 현재 위치 값들(i와 j)의 비교로 +1을 하는 셈이고

2-2의 경우, 이전까지의 비교 중 높은 값을 그대로 가져오는 셈이다.

두 문자열을 비교하는 경우, 2차원 배열인 DP를 채워나가면서 제곱의 시간복잡도가 발생하게 된다.
<br>

#### 관련 알고리즘 문제

백준 [9251 LCS](https://www.acmicpc.net/problem/9251)

LCS를 검색하면 LCS 시리즈 문제를 볼 수 있다.