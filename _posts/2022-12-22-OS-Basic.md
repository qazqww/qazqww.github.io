---
layout: post
title: "Java 멀티 스레딩 - 1. 운영체제 기초"
categories: java
tags: [thread]
---

#### *
Java 멀티스레딩을 공부하기 전, 운영체제가 프로세스와 스레드를 다루는 방식에 대해 간략히 정리해보는 포스트이다.

#### 개요
멀티 스레드는 왜 필요할까?
- 응답성
- 성능
<br>

#### 프로세스
메모리에 적재되어 실행되는 프로그램 인스턴스를 '프로세스' 또는 '애플리케이션 컨텍스트'라고 부른다.

프로세스 안에 있는 메타 데이터
- 프로세스 ID : 애플리케이션을 구별하는 식별자
- 코드 : CPU에서 실행되는 프로그램 명령어
- 데이터(힙) : 애플리케이션에 필요한 모든 데이터
- 스레드
    - 스택 : 메모리 영역, 지역 변수가 저장되고 기능이 실행되는 영역
    - 명령어 포인터 : 스레드가 실행할 다음 명령어의 주소를 가리키는 역할

멀티 스레드에서 각 스레드는 자체 스택과 명령어 포인트를 가지고\
나머지 컴포넌트는 모든 스레드가 공유한다.\
각각의 스레드는 특정 순간에 서로 다른 함수를 이용해 서로 다른 명령을 수행한다.
<br>

#### 컨텍스트 스위치
기존의 스레드 실행을 멈추고, 다른 스레드를 스케줄링한 뒤 실행하는 것을 컨텍스트 스위치라 한다.\
(like 생각 가다듬기)

- 동시에 많은 스레드를 다룰 때에는 효율성이 떨어진다.\
스레드 전환 시에는 기존의 모든 데이터를 저장하고, 불러올 스레드의 리소스를 CPU와 메모리에 복원하는 과정이 필요하다.\
=> 너무 많은 스레드는 스레싱을 유발한다.\
※ 스레싱 : 컨텍스트 스위치에 걸리는 시간이 더 많아짐

스레드는 프로세스보다 리소스를 더 적게 사용한다. 프로세스 내의 스레드들은 공유하는 리소스가 많기 때문이다.\
=> 같은 프로세스 내의 컨텍스트 스위치가 서로 다른 프로세스 간의 컨텍스트 스위치보다 효율적이다.
<br>

#### 쓰레드 스케줄링

기본적인 방법
- First Come First Serve\
문제점 : '기아 현상'. 뒤에 배치된 쓰레드들은 대기시간이 길어져 응답성이 저하된다.

- Shortest Job First\
문제점 : 긴 작업들을 처리하기 위해 너무 많이 기다려야 한다.

- Epochs (에포크)\
일반적인 운영체제에서의 작동
1. 운영체제는 '에포크'에 맞춰 시간을 적당한 크기로 나눈다.
2. 스레드의 타임 슬라이스를 종류 별로 에포크에 할당한다. (모든 스레드가 각 에포크에서 실행되거나 완료되지는 않는다.)
3. 운영체제는 각각의 에포크에 우선순위를 조절하여 부여한다.

Dynamic Priority = Static Priority + Bonus

Static Priority : 개발자가 부여\
Bonus : 운영체제가 각각의 에포크마다 조절하여 부여

운영체제는 즉각적인 반영이 필요한 실시간 스레드나 인터랙티브 스레드(UI 같은)에게 우선권을 준다.\
그리고 기아 현상을 방지하기 위해 이전 에포크에서 실행 시간이 부족했거나 완료되지 않은 스레드도 고려한다.
<br>

#### 멀티 스레드 아키텍처 vs 멀티 프로세스 아키텍처

멀티 스레드 애플리케이션 아키텍처의 장점
- 스레드는 프로세스보다 생성과 파기가 훨씬 빠르기 때문에, 시간 면에서 이득이다.
- 같은 프로세스 안에서의 컨텍스트 스위칭이 더 효율적이다.

멀티 프로세스 애플리케이션 아키텍처의 장점
- 보안과 안정성 측면에서 더 좋다.